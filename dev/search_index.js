var documenterSearchIndex = {"docs":
[{"location":"#UnivariateSplines","page":"Home","title":"UnivariateSplines","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#IgaBase.refine-Tuple{Integer, hRefinement}","page":"Home","title":"IgaBase.refine","text":"refine(p::Degree, R::AbstractRefinement)\n\nChange in polynomial degree based on the refinement type.\n\n\n\n\n\n","category":"method"},{"location":"#IgaBase.refine-Tuple{NonDecreasingVector, hRefinement}","page":"Home","title":"IgaBase.refine","text":"refine(p::KnotVector, R::AbstractRefinement)\n\nChange in knot vector based on the refinement type.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.approximate_collocation_inverse-Union{Tuple{T}, Tuple{Int64, NonDecreasingVector{T}}} where T<:Real","page":"Home","title":"UnivariateSplines.approximate_collocation_inverse","text":"approximate_collocation_inverse(p, U)\napproximate_collocation_inverse(p, U, k1)\n\nCompute an approximate inverse mathsfA  mathsfB^-1, where mathsfB is the consistent B-spline interpolation matrix. The approximation is of order k_1 leq p+1. The quasi-interpolant is designed to reproduce polynomials\n\n    sum_i=1^n mu_i(x^k) B_ip(x) = x^k  quad textfor  k=01k_1-1\n\nand is based on the following paper\n\nT. Lyche and L. L. Schumaker. Local spline approximation methods. Journal of Approximation Theory, 15(4):294-325, Dec. 1975.\n\nExamples:\n\njulia> p  = Degree(3);\n\njulia> U  = KnotVector([0.0,1.0,1.5,2.5,3.0], [p+1,1,1,2,p+1]);\n\njulia> y  = grevillepoints(p, U);\n\nThe approximate collocation inverse, using full approximation order k_1=p+1 and the consistent collocation matrix are computed as follows\n\njulia> A = approximate_collocation_inverse(p, U, p+1);\n\njulia> B = bspline_interpolation_matrix(p, U, y, 1)[1];\n\nIt can be verified that the quasi-interpolant reproduces constants, linears, quadratic and cubic polynomials\n\njulia> B * A * (y.^0) ≈ y.^0\ntrue\n\njulia> B * A * (y.^1) ≈ y.^1\ntrue\n\njulia> B * A * (y.^2) ≈ y.^2\ntrue\n\njulia> B * A * (y.^3) ≈ y.^3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.approximate_l2_inverse-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}, Int64}} where T<:Real","page":"Home","title":"UnivariateSplines.approximate_l2_inverse","text":"approximate_l2_inverse(p, U, k1)\n\nCompute an approximate inverse mathsfS  mathsfM^-1, where mathsfM is the consisten B-spline mass matrix. The approximation is of order k_1 leq p+1. The L^2 quasi-interpolant is designed to reproduce polynomials\n\n    sum_i=1^n mu_i(x^k) B_ip(x) = x^k  quad textfor  k=01k_1-1\n\nand is based on the following paper\n\nChui, Charles K., Wenjie He, and Joachim Stöckler. \"Nonstationary tight wavelet frames, I: Bounded intervals.\" Applied and Computational Harmonic Analysis 17.2 (2004): 141-197.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.bezier_extraction_operator-Union{Tuple{T}, Tuple{Integer, NonDecreasingVector{T}}} where T<:Real","page":"Home","title":"UnivariateSplines.bezier_extraction_operator","text":"bezier_extraction_operator(p, U)\n\nCompute the Bézier extraction operators corresponding to a B-spline basis of polynomial degree p and knot vector U. The output is a 3-dimensional array mathsfC in mathbbR^(p+1) times (p+1) times n_el.\n\nThe implementation is based on the following paper\n\nBorden, Michael J., et al. \"Isogeometric finite element data structures based on Bézier extraction of NURBS.\" International Journal for Numerical Methods in Engineering 87.1‐5 (2011): 15-47.\n\nExamples:\n\njulia> p = Degree(2); U = KnotVector([0.0,0.0,0.0,1.0,3.0,3.0,4.0,4.0,4.0]);\n\njulia> bezier_extraction_operator(p, U)\n3×3×3 Array{Float64, 3}:\n[:, :, 1] =\n 1.0  0.0       0.0\n 0.0  1.0       0.0\n 0.0  0.666667  0.333333\n\n[:, :, 2] =\n 0.666667  0.333333  0.0\n 0.0       1.0       0.0\n 0.0       0.0       1.0\n\n[:, :, 3] =\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.bspline_integral_value-Tuple{Integer, NonDecreasingVector, Integer}","page":"Home","title":"UnivariateSplines.bspline_integral_value","text":"bspline_integral_value(p, U, i::Int)\nbspline_integral_value(p, U)\n\nCompute the integral of a b-spline function defined by degree p and knotvector U.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.bspline_interpolation_matrix","page":"Home","title":"UnivariateSplines.bspline_interpolation_matrix","text":"bspline_interpolation_matrix(p, U, i, x, nout=1)\n\nGiven the polynomial degree p and knot-vector U compute the collocation matrices of the B-spline basis functions sampled at a set of points x. The output is a set of sparse matrices whose rows correspond to the evaluation points and whose columns are associated with the B-spline degrees of freedom.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,1.0,1.5,2.5,3.0], [3,1,1,2,3]);\n\njulia> x = IncreasingVector([0.5,1.5,2.75]);\n\njulia> B = bspline_interpolation_matrix(p, U, x, p+1);\n\nThe interpolation matrix for quadratic B-splines is\n\njulia> B[1]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:\n 0.25  0.583333  0.166667   ⋅         ⋅     ⋅    ⋅ \n  ⋅     ⋅        0.666667  0.333333  0.0    ⋅    ⋅ \n  ⋅     ⋅         ⋅         ⋅        0.25  0.5  0.25\n\nThe interpolation matrix for linear and constant B-splines is given by\n\njulia> B[2]\n3×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 6 stored entries:\n 0.5  0.5   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0  0.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   0.5  0.5\n\njulia> B[3]\n3×5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0\n\nIt can be easily verified that the B-splines satisfy a partition of unity\n\njulia> sum(B[1],dims=2)\n3×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n\njulia> sum(B[2],dims=2)\n3×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n\njulia> sum(B[3],dims=2)\n3×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n\nThe collocation matrices can be used to solve an interpolation problem or a PDE using the collocation method. For example, the interpolation matrix evaluated at the Greville points can be computed as follows\n\njulia> x = grevillepoints(p, U);\n\njulia> B = bspline_interpolation_matrix(p, U, x, p+1)[1]\n7×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 21 stored entries:\n 1.0   0.0        0.0        ⋅          ⋅     ⋅    ⋅ \n 0.25  0.583333   0.166667   ⋅          ⋅     ⋅    ⋅ \n  ⋅    0.0833333  0.833333  0.0833333   ⋅     ⋅    ⋅ \n  ⋅     ⋅         0.166667  0.583333   0.25   ⋅    ⋅ \n  ⋅     ⋅          ⋅         ⋅         1.0   0.0  0.0\n  ⋅     ⋅          ⋅         ⋅         0.25  0.5  0.25\n  ⋅     ⋅          ⋅         ⋅         0.0   0.0  1.0\n\nThe matrix mathsfB can then be used to interpolate a univariate function. For example, up to quadratic polynomials are exactly reproduced\n\n# sample grid to test polynomial reproduction\njulia> y = global_insert(x, 4);\n\njulia> C = bspline_interpolation_matrix(p, U, y, 1)[1];\n\njulia> C * (B \\ x.^0) ≈ y.^0\ntrue\n\njulia> C * (B \\ x.^1) ≈ y.^1\ntrue\n\njulia> C * (B \\ x.^2) ≈ y.^2\ntrue\n\nHere matrix mathsfC evaluates the B-spline at a refined partition y.\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateSplines.bsplinebasisfuns","page":"Home","title":"UnivariateSplines.bsplinebasisfuns","text":"bsplinebasisfuns(p, U, i::Integer, x::T, nout=1)\nbsplinebasisfuns(p, U, x::T, nout=1)\n\nCompute the p+1 non-zero B-spline basis-functions at site x in U_iU_i+1). The output is a matrix where column j (rows 1p+2-j), for j=1n_out correspond to the p+2-j non-zero B-spline basis functions of degree p+1-j. The remaining entries correspond to supports. If the active knot-span is not provided then it will be computed.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,0.0,0.0,1.0,2.0,2.0,2.0]);\n\njulia> x = 1.5\n1.5\n\njulia> span = findspan(p, U, x)\n4\n\njulia> B = bsplinebasisfuns(p, U, span, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  0.5  1.0\n 0.625  0.5  1.0\n 0.25   1.0  2.0\n\nThe knot span index can be omited, in which case it is computed on the fly.\n\njulia> bsplinebasisfuns(p, U, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  0.5  1.0\n 0.625  0.5  1.0\n 0.25   1.0  2.0\n\nBy prescribing a vector of m sites x in mathbbR^m we can compute the B-splines at more than one point. The function can be called with or without prescribing the knot-span index\n\nbsplinebasisfuns(p, U, span::Vector{Integer}, u::Vector{T}, nout=1)\nbsplinebasisfuns(p, U, u::SortedSequence{T}, nout=1)\n\nThe output is a 3-dimensional array B in mathbbR^(p+1) times m times n_out.\n\nExamples:\n\njulia> x = IncreasingVector([0.5, 1.5]);\n\njulia> span = findspan(p, U, x)\n2-element NonDecreasingVector{Int64}:\n 3\n 4\n\njulia> bsplinebasisfuns(p, U, span, x, p+1)\n3×2×3 Array{Float64, 3}:\n[:, :, 1] =\n 0.25   0.125\n 0.625  0.625\n 0.125  0.25\n\n[:, :, 2] =\n 0.5  0.5\n 0.5  0.5\n 2.0  1.0\n\n[:, :, 3] =\n 1.0  1.0\n 1.0  1.0\n 1.0  2.0\n\nAlternatively, the non-vanishing B-splines up to and including degree p can be computed at n_el non-zero knot-spans (elements) with m sites each, that is, x in mathbbR^m times n_el. Again, the function can be called with or without prescribing the knot-span index\n\nbsplinebasisfuns(p, U, span::Vector{Int64}, u::Matrix{T}, nout=1)\nbsplinebasisfuns(p, U, u::Matrix{T}, nout=1)\n\nThe output is a 4-dimensional array B in mathbbR^(p+1) times m times n_el times n_out.\n\nExamples:\n\njulia> x = [0.25 1.25;\n            0.75 1.75];\n\njulia> bsplinebasisfuns(p, U, x, p+1)\n3×2×2×3 Array{Float64, 4}:\n[:, :, 1, 1] =\n 0.5625   0.0625\n 0.40625  0.65625\n 0.03125  0.28125\n\n[:, :, 2, 1] =\n 0.28125  0.03125\n 0.65625  0.40625\n 0.0625   0.5625\n\n[:, :, 1, 2] =\n 0.75  0.25\n 0.25  0.75\n 2.0   2.0\n\n[:, :, 2, 2] =\n 0.75  0.25\n 0.25  0.75\n 1.0   1.0\n\n[:, :, 1, 3] =\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n\n[:, :, 2, 3] =\n 1.0  1.0\n 1.0  1.0\n 2.0  2.0\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateSplines.ders_bspline_interpolation_matrix","page":"Home","title":"UnivariateSplines.ders_bspline_interpolation_matrix","text":"ders_bspline_interpolation_matrix(p, U, i, x, nout=1)\n\nGiven the polynomial degree p and knot-vector U compute the collocation matrices of the first n_out derivatives of the B-spline basis functions sampled at a set of points x. The output is a set of sparse matrices whose rows correspond to the evaluation points and whose columns are associated with the B-spline degrees of freedom.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,1.0,1.5,2.5,3.0], [3,1,1,2,3]);\n\njulia> x = IncreasingVector([0.5,1.5,2.75]);\n\njulia> B = ders_bspline_interpolation_matrix(p, U, x, p+1);\n\nThe output is a set of SparseMatrixCSC matrices. For example the B-splines evaluate at points x are\n\njulia> B[1]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:                       \n 0.25  0.583333  0.166667   ⋅         ⋅     ⋅    ⋅                                            \n  ⋅     ⋅        0.666667  0.333333  0.0    ⋅    ⋅                                            \n  ⋅     ⋅         ⋅         ⋅        0.25  0.5  0.25                                          \n\nDerivatives of quadratic B-splines evaluated at x\n\njulia> B[2]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:\n -1.0  0.333333   0.666667   ⋅         ⋅    ⋅    ⋅ \n   ⋅    ⋅        -1.33333   1.33333   0.0   ⋅    ⋅ \n   ⋅    ⋅          ⋅         ⋅       -2.0  0.0  2.0\n\nSecond derivatives of quadratic B-splines evaluated at x\n\njulia> B[3]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:\n 2.0  -3.33333  1.33333    ⋅        ⋅      ⋅    ⋅ \n  ⋅     ⋅       1.33333  -3.33333  2.0     ⋅    ⋅ \n  ⋅     ⋅        ⋅         ⋅       8.0  -16.0  8.0\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateSplines.dersbsplinebasisfuns","page":"Home","title":"UnivariateSplines.dersbsplinebasisfuns","text":"dersbsplinebasisfuns(p, U, span::Int, u::T, nout=1)\ndersbsplinebasisfuns(p, U, u::T, nout=1)\n\nCompute the non-vanishing B-spline basis-functions of degree p and their n_out-1'th order derivatives at the site x. The output is a matrix B in mathbbR^(p+1) times n_out where the i'th row corresponds to the i'th non-vanishing B-spline at x and the j'th column corresponds to the j-1'th derivative.\n\nThe implementation of this function is based on\n\nPiegl, Les, and Wayne Tiller. The NURBS book. Springer Science & Business Media, 2012.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,0.0,0.0,1.0,2.0,2.0,2.0]);\n\njulia> x = 1.5;\n\njulia> span = findspan(p, U, x)\n4\n\njulia> dersbsplinebasisfuns(p, U, span, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  -0.5   1.0\n 0.625  -0.5  -3.0\n 0.25    1.0   2.0\n\ndersbsplinebasisfuns can also be called without providing the span-indices, in which case they will be calculated on the fly.\n\njulia> dersbsplinebasisfuns(p, U, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  -0.5   1.0\n 0.625  -0.5  -3.0\n 0.25    1.0   2.0\n\nBy prescribing a vector of m sites x in mathbbR^m we can compute the B-splines and their derivatives at more than one point.  The function can be called with or without prescribing the knot-span index\n\ndersbsplinebasisfuns(p, U, span::Vector{Integer}, u::Vector{T}, nout=1)\ndersbsplinebasisfuns(p, U, u::SortedSequence{T}, nout=1)\n\nThe output is a 3-dimensional array B in mathbbR^(p+1) times m times n_out.\n\nExamples:\n\njulia> x = IncreasingVector([0.5, 1.5]);\n\njulia> span = findspan(p, U, x)\n2-element NonDecreasingVector{Int64}:\n 3\n 4\n\njulia> dersbsplinebasisfuns(p, U, span, x, p+1)\n3×2×3 Array{Float64, 3}:\n[:, :, 1] =\n 0.25   0.125\n 0.625  0.625\n 0.125  0.25\n\n[:, :, 2] =\n -1.0  -0.5\n  0.5  -0.5\n  0.5   1.0\n\n[:, :, 3] =\n  2.0   1.0\n -3.0  -3.0\n  1.0   2.0\n\nAlternatively, the non-vanishing derivatives of the B-splines can be computed at n_el non-zero knot-spans (elements) with m sites each, that is, x in mathbbR^m times n_el. Again, the function can be called with or without prescribing the knot-span index\n\ndersbsplinebasisfuns(p, U, span::Vector{Int64}, u::Matrix{T}, nout=1)\ndersbsplinebasisfuns(p, U, u::Matrix{T}, nout=1)\n\nThe output is a 4-dimensional array B in mathbbR^(p+1) times m times n_el times n_out.\n\nExamples:\n\njulia> x = [0.25 1.25;\n            0.75 1.75];\n\njulia> dersbsplinebasisfuns(p, U, x, p+1)\n3×2×2×3 Array{Float64, 4}:\n[:, :, 1, 1] =\n 0.5625   0.0625\n 0.40625  0.65625\n 0.03125  0.28125\n\n[:, :, 2, 1] =\n 0.28125  0.03125\n 0.65625  0.40625\n 0.0625   0.5625\n\n[:, :, 1, 2] =\n -1.5   -0.5\n  1.25  -0.25\n  0.25   0.75\n\n[:, :, 2, 2] =\n -0.75  -0.25\n  0.25  -1.25\n  0.5    1.5\n\n[:, :, 1, 3] =\n  2.0   2.0\n -3.0  -3.0\n  1.0   1.0\n\n[:, :, 2, 3] =\n  1.0   1.0\n -3.0  -3.0\n  2.0   2.0\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateSplines.dimsplinespace-Tuple{Integer, NonDecreasingVector}","page":"Home","title":"UnivariateSplines.dimsplinespace","text":"dimsplinespace(p, U)\n\nCompute the dimension of the spline space defined by degree p and knotsvector U.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.distribute_points-Tuple{SplineSpace, SplineSpace}","page":"Home","title":"UnivariateSplines.distribute_points","text":"distribute_points(S::SplineSpace, V::SplineSpace; add_boundary_points::Bool=false)\n\nCompute distribution of quadrature points in weigthed quadrature with a test-space V and target space for quadrature S. The nodes are distribute in such a way that all conditions for exact quadrature are satisfied with a minimum number of points.\n\nThe distribution of quadrature points in weighted quadrature is based on the following paper.\n\nHiemstra, René R., et al. \"Fast formation and assembly of finite element matrices with application to isogeometric linear elasticity.\" Computer Methods in Applied Mechanics and Engineering 355 (2019): 234-260.\n\nExamples:\n\njulia> S = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,2,2,3]);\n\njulia> V = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,1,1,3]);\n\njulia> UnivariateSplines.distribute_points(S, V)\n8-element IncreasingVector{Float64}:\n 0.16666666666666666\n 0.5\n 0.8333333333333334\n 1.25\n 1.75\n 2.1666666666666665\n 2.5\n 2.8333333333333335\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.extraction_operator-Tuple{Integer, NonDecreasingVector}","page":"Home","title":"UnivariateSplines.extraction_operator","text":"extraction_operator(p::Degree, U::KnotVector; [cperiodic, cleft, cright])\n\nCompute an extraction operator that creates a subspace of the SplineSpace with for example peroidicity built-in.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.findspan-Union{Tuple{T}, Tuple{Integer, NonDecreasingVector{T}, T}} where T<:Real","page":"Home","title":"UnivariateSplines.findspan","text":"findspan(p, U, u)\n\nGiven polynomial degree p and knotvector U determine the knot span index i of a point x such that u in U_i U_i+1).\n\nExamples:\n\njulia> p = Degree(2)\n2\n\njulia> U = KnotVector([0.0,1.0,1.5,2.5,3.0],[3,1,1,2,3])\n10-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 1.0\n 1.5\n 2.5\n 2.5\n 3.0\n 3.0\n 3.0\n\njulia> x = 2.0\n2.0\n\njulia> span = findspan(p, U, x)\n5\n\njulia> U[span] ≤ x < U[span+1]\ntrue\n\nIt is also possible to compute the knot-spans of all values in an 'IncreasingVector{T}'\n\njulia> x = IncreasingVector([0.25, 0.75, 1.0, 1.25, 2.5, 2.75]);\n\njulia> span = findspan(p, U, x)\n6-element NonDecreasingVector{Int64}:\n 3\n 3\n 4\n 4\n 7\n 7\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.grevillepoints-Tuple{Integer, NonDecreasingVector, Integer}","page":"Home","title":"UnivariateSplines.grevillepoints","text":"grevillepoints(p, U, i)\ngrevillepoints(p, U)\n\nCompute the i'th Greville Absissa corresponding to the i'th B-spline defined by degree 'p' and knotvector 'U' of spline space.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,1.0,2.5,3.0], [3,1,2,1])\n7-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 1.0\n 2.5\n 2.5\n 3.0\n\njulia> grevillepoints(p, U, 2)\n0.5\n\njulia> grevillepoints(p, U)\n4-element IncreasingVector{Float64}:\n 0.0\n 0.5\n 1.75\n 2.5\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.h_refinement_operator!-Union{Tuple{T}, Tuple{Integer, NonDecreasingVector{T}, Integer, T}} where T<:Real","page":"Home","title":"UnivariateSplines.h_refinement_operator!","text":"h_refinement_operator!(p::Degree, U::KnotVector{T}, u::AbstractVector{T}) where {T<:Real}\nh_refinement_operator!(p::Degree, U::KnotVector{T}, u::T) where {T<:Real}\nh_refinement_operator!(p::Degree, U::KnotVector{T}, span::Integer, u::T) where {T<:Real}\n\nInsert one or more knots u into knotvector U and output the transformation operator from the coarse to the refined space. The knotvector is updated in-place. The output is represented as a SparseMatrixCSC matrix.\n\nExamples:\n\njulia> p = Degree(2)\n2\n\njulia> U = KnotVector([0.0,1.0,2.0,3.0,4], [3,1,1,2,3])\n10-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 1.0\n 2.0\n 3.0\n 3.0\n 4.0\n 4.0\n 4.0\n\njulia> C = h_refinement_operator!(p, U, [0.5, 1.5, 2.5, 3.5]); # sparse matrix\n\njulia> Matrix(C)\n11×7 Matrix{Float64}:\n 1.0  0.0   0.0   0.0   0.0  0.0  0.0\n 0.5  0.5   0.0   0.0   0.0  0.0  0.0\n 0.0  0.75  0.25  0.0   0.0  0.0  0.0\n 0.0  0.25  0.75  0.0   0.0  0.0  0.0\n 0.0  0.0   0.75  0.25  0.0  0.0  0.0\n 0.0  0.0   0.25  0.75  0.0  0.0  0.0\n 0.0  0.0   0.0   0.5   0.5  0.0  0.0\n 0.0  0.0   0.0   0.0   1.0  0.0  0.0\n 0.0  0.0   0.0   0.0   0.5  0.5  0.0\n 0.0  0.0   0.0   0.0   0.0  0.5  0.5\n 0.0  0.0   0.0   0.0   0.0  0.0  1.0\n\njulia> @show U;\nU = [0.0, 0.0, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.5, 4.0, 4.0, 4.0]\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.normalization_weights-Union{Tuple{IncreasingVector{T}}, Tuple{T}} where T<:Real","page":"Home","title":"UnivariateSplines.normalization_weights","text":"normalization_weights(X)\n\nDetermine a set of normalization weights that result in a more uniform set oftype( weighted quadrature weights when solving for the least norm solution. )\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.nquadpoints-Tuple{SplineSpace, SplineSpace}","page":"Home","title":"UnivariateSplines.nquadpoints","text":"nquadpoints(S::SplineSpace, V::SplineSpace; add_boundary_points=false, add_additional_points=0, min_points=1)\n\nDetermine the minimum number of quadrature points corresponding to a weighted quadrature rule with test-space V and target-space S.\n\nExamples:\n\njulia> S = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,2,2,3]);\n\njulia> V = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,1,1,3]);\n\njulia> A = UnivariateSplines.nquadpoints(S, V; add_boundary_points=false)\n3-element Vector{Int64}:\n 3\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.num_elements-Tuple{NonDecreasingVector}","page":"Home","title":"UnivariateSplines.num_elements","text":"num_elements(U::KnotVector)\n\nCount the number of non-zero knot spans or elements in the knotvector.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.onebasisfuneval-Union{Tuple{T}, Tuple{NonDecreasingVector{T}, T}} where T<:Real","page":"Home","title":"UnivariateSplines.onebasisfuneval","text":"onebasisfuneval(U, u)\n\nCompute value of a single B-spline basis-function defined by local knotvector 'U' evaluated at point 'x'.\n\nThe implementation of this function is taken from\n\nPiegl, Les, and Wayne Tiller. The NURBS book. Springer Science & Business Media, 2012.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.refinement_operator-Tuple{Integer, NonDecreasingVector, IgaBase.AbstractRefinement}","page":"Home","title":"UnivariateSplines.refinement_operator","text":"refinement_operator(p::Degree, U::KnotVector, method::AbstractRefinement)\n\nCompute the two_scale_operator given p and U and the applicable refinement strategy: IgaBase.hRefinement(), IgaBase.pRefinement(), IgaBase.kRefinement(). See IgaBase package for definition of refinement methods.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.solve_leastnorm_without_constraints-Union{Tuple{T}, Tuple{Matrix{T}, Vector{T}}, Tuple{Matrix{T}, Vector{T}, Any}} where T<:Real","page":"Home","title":"UnivariateSplines.solve_leastnorm_without_constraints","text":"solve_leastnorm_without_constraints(A, b, S=BigFloat)\n\nSolve underdetermined system of equation A x = b using QR factorization with arbitrary precision.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.table_required_points-Tuple{SplineSpace, SplineSpace}","page":"Home","title":"UnivariateSplines.table_required_points","text":"table_required_points(S, V)\n\nDetermine the number of exactness conditions in subsets of elements. The output is a matrix mathsfA where mathsfA_ij denotes the minimum number of points required in interval ij to perform exact weighted quadrature.\n\nExamples:\n\njulia> S = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,2,2,3]);\n\njulia> V = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,1,1,3]);\n\njulia> A = UnivariateSplines.table_required_points(S, V)\n3×3×1 Array{Int64, 3}:\n[:, :, 1] =\n 3  5  7\n 2  5  0\n 3  0  0\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.two_scale_operator-Union{Tuple{T}, Tuple{Integer, NonDecreasingVector{T}, Integer, NonDecreasingVector{T}}} where T<:Real","page":"Home","title":"UnivariateSplines.two_scale_operator","text":"two_scale_operator(p::Degree, U::KnotVector{T}, q::Degree, V::KnotVector{T}) where {T<:Real}\n\nThe two_scale_operator encodes the main logic for all spline refinemement operations.\n\nThe arguments p and U correspond to the current spline space and q and V are the \"target\" degree knot vector.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.unit_integral_rescaling-Tuple{Integer, NonDecreasingVector, Integer}","page":"Home","title":"UnivariateSplines.unit_integral_rescaling","text":"unit_integral_rescaling(p, U, i::Int)\nunit_integral_rescaling(p, U)\n\nCompute the scaling factors that normalize the B-spline basis functions to have unit integral.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.wquadweights!-Union{Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T}, SparseArrays.SparseMatrixCSC{T}, SparseArrays.SparseMatrixCSC{T}, Vector{T}}} where T<:Real","page":"Home","title":"UnivariateSplines.wquadweights!","text":"wquadweights!(M, B, W, C)\n\nCompute the quadrature weights in weighted quadrature such that M ≈ W' * B.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateSplines.Bspline","page":"Home","title":"UnivariateSplines.Bspline","text":"Bspline{T} <: ScalarMapping{1}\n\nA univariate B-spline function of field T.\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.BsplineBasis","page":"Home","title":"UnivariateSplines.BsplineBasis","text":"BsplineBasis{T<:Real} <: Basis{T,3}\n\nSpecial array type for storing evaluating B-spline and their derivatives.\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.BsplineEvaluationCache","page":"Home","title":"UnivariateSplines.BsplineEvaluationCache","text":"BsplineEvaluationCache <: EvaluationCache{1}\n\nCache that caches basis function evaluation at a set of evaluation points.\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.BsplineSupport","page":"Home","title":"UnivariateSplines.BsplineSupport","text":"BsplineSupport(S::SplineSpace)\n\nIterator that outputs the supporting elements of each B-spline basis-function as a UnitRange{Int64}.\n\nExample:\n\njulia> S = SplineSpace(2, [0.0,2.0,3.0], [3,1,3]);\n\njulia> for α in BsplineSupport(S)\n           @show α\n       end\nα = 1:1\nα = 1:2\nα = 1:2\nα = 2:2\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.GeneralizedGaussrule","page":"Home","title":"UnivariateSplines.GeneralizedGaussrule","text":"GeneralizedGaussrule(p, r, nel, a, b)\n\nCompute a generalized Gaussian quadrature rule for a target spline-space mathbbS^p_r(ab) defined in a uniform partition with n_el elements.\n\nThese rules are made available in the following paper\n\nHiemstra, René R., et al. \"Optimal and reduced quadrature rules for tensor product and hierarchically refined splines in isogeometric analysis.\" Computer Methods in Applied Mechanics and Engineering 316 (2017): 966-1004.\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.KnotSpanIndices","page":"Home","title":"UnivariateSplines.KnotSpanIndices","text":"KnotSpanIndices\n\nA sorted sequence of integers that refer to the corresponding non-zero knot span of a KnotVector.\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.KnotVector","page":"Home","title":"UnivariateSplines.KnotVector","text":"KnotVector{T<:Real}\n\nA knot-vector is a non-decreasing sequence of real numbers. (typeallias of NonDecreasingVector{T})\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.SpanIndex","page":"Home","title":"UnivariateSplines.SpanIndex","text":"SpanIndex(S::SplineSpace)\n\nIterator that outputs the span index corresponding to each element in the partition\n\nExample:\n\njulia> S = SplineSpace(2, [0.0,1.0,2.0,3.0,4.0], [3,1,2,1,3]);\n\njulia> for s in SpanIndex(S)\n           @show s\n       end\ns = 3\ns = 4\ns = 6\ns = 7\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.SplineSpace","page":"Home","title":"UnivariateSplines.SplineSpace","text":"SplineSpace(p, U)\nSplineSpace(p, x, m)\nSplineSpace(p, Interval(a, b), num_elements)\n\nDefinition of a spline space by means of the polynomial degree p, a sequence of break-points x and the knot-multiplicity m or by prescribing the knot-vector U.\n\nExamples:\n\njulia> S = SplineSpace(2, [0.0,2.0,3.0], [3,1,3])\nSplineSpace(degree = 2, interval = [0.0, 3.0], dimension = 4)\n\njulia> dimsplinespace(S)\n4\n\njulia> Degree(S)\n2\n\njulia> KnotVector(S)\n7-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 2.0\n 3.0\n 3.0\n 3.0\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.Support","page":"Home","title":"UnivariateSplines.Support","text":"BsplineSupport(S::SplineSpace)\n\nIterator that outputs the supporting elements of each B-spline basis-function as a UnitRange{Int64}.\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateSplines.WeightedQuadrule","page":"Home","title":"UnivariateSplines.WeightedQuadrule","text":"WeightedQuadrule{T<:Real} <: AbstractQuadrule{1}\n\nWeighted quadrature rules are test function specific quadrature rules that exactly integrate all functions in a targetspace. The rules are computed in high precision and are accurate up to 16 digits.\n\n\n\n\n\n","category":"type"}]
}
